var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JLSO]\nPublic = true\nPrivate = true\nPages = [\"JLSO.jl\", \"JLSOFile.jl\", \"metadata.jl\", \"file_io.jl\", \"serialization.jl\"]","category":"page"},{"location":"api/#JLSO.JLSO","page":"API","title":"JLSO.JLSO","text":"A julia serialized object (JLSO) file format for storing checkpoint data.\n\nStructure\n\nThe .jlso files are BSON files containing the dictionaries with a specific schema. NOTE: The raw dictionary should be loadable by any BSON library even if serialized objects themselves aren't reconstructable.\n\nExample)\n\nDict(\n    \"metadata\" => Dict(\n        \"version\" => v\"2.0\",\n        \"julia\" => v\"1.0.4\",\n        \"format\" => :bson,  # Could also be :julia_serialize\n        \"compression\" => :gzip_fastest, # could also be: :none, :gzip_smallest, or :gzip\n        \"image\" => \"xxxxxxxxxxxx.dkr.ecr.us-east-1.amazonaws.com/myrepository:latest\"\n        \"project\" => Dict{String, Any}(...),\n        \"manifest\" => Dict{String, Any}(...),\n    ),\n    \"objects\" => Dict(\n        \"var1\" => [0x35, 0x10, 0x01, 0x04, 0x44],\n        \"var2\" => [...],\n    ),\n)\n\nWARNING: Regardless of serialization format, the serialized objects can not be deserialized into structures with different fields, or if the types have been renamed or removed from the packages. Further, the :julia_serialize format is not intended for long term storage and is not portable across julia versions. As a result, we're storing the serialized object data in a json file which should also be able to load the docker image and versioninfo to allow reconstruction.\n\n\n\n\n\n","category":"module"},{"location":"api/#JLSO.JLSOFile-Tuple{Dict{Symbol,var\"#s13\"} where var\"#s13\"}","page":"API","title":"JLSO.JLSOFile","text":"JLSOFile(data; format=:julia_serialize, compression=:gzip, kwargs...)\n\nStores the information needed to write a .jlso file.\n\nArguments\n\ndata - The objects to be stored in the file.\n\nKeywords\n\nimage=\"\" - The docker image URI that was used to generate the file\njulia=1.5.3 - The julia version used to write the file\nversion=v\"4\" - The file schema version\nformat=:julia_serialize - The format to use for serializing individual objects. While :bson is   recommended for longer term object storage, :julia_serialize tends to be the faster choice   for adhoc serialization.\ncompression=:gzip, what form of compression to apply to the objects.   Use :none, to not compress. :gzip_fastest for the fastest gzip compression,   :gzip_smallest for the most compact (but slowest), or :gzip for a generally good compromise.   Due to the time taken for disk IO, :none is not normally as fast as using some compression.\n\n\n\n\n\n","category":"method"},{"location":"api/#JLSO.load-Tuple{Union{AbstractString, FilePathsBase.AbstractPath},Vararg{Any,N} where N}","page":"API","title":"JLSO.load","text":"load(io, objects...) -> Dict{Symbol, Any}\nload(path, objects...) -> Dict{Symbol, Any}\n\nLoad the JLSOFile from the io and deserialize the specified objects. If no object names are specified then all objects in the file are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#JLSO.save-Tuple{IO,Any}","page":"API","title":"JLSO.save","text":"save(io, data)\nsave(path, data)\n\nCreates a JLSOFile with the specified data and kwargs and writes it back to the io.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{JLSOFile,Symbol}","page":"API","title":"Base.getindex","text":"getindex(jlso, name)\n\nReturns the deserialized object with the specified name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{JLSOFile,Any,Symbol}","page":"API","title":"Base.setindex!","text":"setindex!(jlso, value, name)\n\nAdds the object to the file and serializes it.\n\n\n\n\n\n","category":"method"},{"location":"api/#JLSO.complete_compression-Tuple{Any}","page":"API","title":"JLSO.complete_compression","text":"complete_compression(compressing_buffer)\n\nWrites any end of compression sequence to the compressing buffer; but does not close the underlying stream. The compressing_buffer itself should not be used after this operation\n\n\n\n\n\n","category":"method"},{"location":"upgrading/#Upgrading","page":"Upgrading","title":"Upgrading","text":"","category":"section"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"JLSO.jl will automatically upgrade older versions of the file format when you call JLSO.load or read.","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"using JLSO\ndir = joinpath(dirname(dirname(pathof(JLSO))), \"test\", \"specimens\")\njlso = read(joinpath(dir, v1_bson.jlso\"), JLSOFile)","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"Upgrading to v3 requires generating a new manifest and project fields from the legacy pkgs field (as seen above) which can be slow and may require manual intervention to address package name collisions across registries. JLSO.upgrade can be used to mitigate these issues.","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"To upgrade a single file:","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"JLSO.upgrade(joinpath(dir, \"v1_bson.jlso\"), \"v3_bson.jlso\")","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"To batch upgrade files created with the same environment:","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"filenames = [\"v1_bson.jlso\", \"v1_serialize.jlso\"]\nJLSO.upgrade(joinpath.(dir, filenames), filenames)","category":"page"},{"location":"upgrading/","page":"Upgrading","title":"Upgrading","text":"In the above case, the project and manifest is only generated for the first file and reused for all subsequent files.","category":"page"},{"location":"#JLSO","page":"Home","title":"JLSO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Code Style: Blue) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JLSO is a storage container for serialized Julia objects. Think of it less as a serialization format but as a container, that employs a serializer, and a compressor, handles all the other concerns including metadata and saving. Such that the serializer just needs to determine how to turn a julia object into a streamVector{UInt8}, and the compressor just needs to determine how to turn one stream of UInt8s into a smaller one (and the reverse).","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the top-level it is a BSON file, where it stores metadata about the system it was created on as well as a collection of objects (the actual data). Depending on configuration, those objects may themselves be stored as BSON sub-documents, or in the native Julia serialization format (default), under various levels of compression (gzip default). It is fast and efficient to load just single objects out of a larger file that contains many objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The metadata includes the Julia version and the versions of all packages installed. It is always store in plain BSON without julia specific extensions. This means in the worst case you can install everything again and replicate your system. (Extreme worst case scenario, using a BSON reader from another programming language).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: If the amount of data you have to store is very small, relative to the metadata about your environment, then JLSO is a pretty suboptimal format.","category":"page"},{"location":"#Basic-Example:","page":"Home","title":"Basic Example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using JLSO, Dates\n\njulia> JLSO.save(\"breakfast.jlso\", :food => \"â˜•ï¸ðŸ¥“ðŸ³\", :cost => 11.95, :time => Time(9, 0))\n\njulia> loaded = JLSO.load(\"breakfast.jlso\")\nDict{Symbol,Any} with 3 entries:\n  :cost => 11.95\n  :time => 09:00:00\n  :food => \"â˜•ï¸ðŸ¥“ðŸ³\"","category":"page"},{"location":"metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Manually reading JLSO files can be helpful when addressing issues deserializing objects or to simply to help with reproducibility.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"using JLSO\njlso = read(\"breakfast.jlso\", JLSOFile)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Now we can manually access the serialized objects:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"jlso.objects","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Or deserialize individual objects:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"jlso[:food]","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Maybe you need to figure out what the environment state was when you wrote the file?","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"jlso.project\njlso.manifest","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"These project and manifest fields are just the dictionary representations of the Project.toml and Manifest.toml files found in a Julia Pkg environment. As such, we can also use Pkg.activate to construct and environment matching that used to write the file.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"julia> using JLSO, Pkg\n\njulia> dir = joinpath(dirname(dirname(pathof(JLSO))), \"test\", \"specimens\")\n\"/Users/rory/repos/invenia/JLSO.jl/test/specimens\"\n\njulia> jlso = read(joinpath(dir, \"v4_bson_none.jlso\"), JLSOFile)\nJLSOFile([ZonedDateTime, DataFrame, Vector, DateTime, String, Matrix, Distribution]; version=\"4.0.0\", julia=\"1.0.5\", format=:bson, compression=:none, image=\"\")\n\njulia> # Can't load some object in the current environment\n       jlso[:DataFrame]\n[warn | JLSO]: UndefVarError: DataFrames not defined\n1355-element Array{UInt8,1}:\n 0x4b\n 0x05\n 0x00\n 0x00\n 0x02\n 0x74\n 0x61\n 0x67\n 0x00\n 0x07\n 0x00\n 0x00\n 0x00\n 0x73\n 0x74\n 0x72\n 0x75\n 0x63\n 0x74\n 0x00\n 0x03\n 0x74\n 0x79\n 0x70\n 0x65\n 0x00\n 0x00\n 0x01\n 0x00\n 0x00\n 0x02\n 0x74\n 0x61\n 0x67\n 0x00\n 0x09\n 0x00\n 0x00\n 0x00\n 0x64\n 0x61\n 0x74\n 0x61\n    â‹®\n 0x33\n 0x00\n 0x21\n 0x00\n 0x00\n 0x00\n 0x02\n 0x74\n 0x61\n 0x67\n 0x00\n 0x07\n 0x00\n 0x00\n 0x00\n 0x73\n 0x79\n 0x6d\n 0x62\n 0x6f\n 0x6c\n 0x00\n 0x02\n 0x6e\n 0x61\n 0x6d\n 0x65\n 0x00\n 0x02\n 0x00\n 0x00\n 0x00\n 0x64\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> using DataFrames\nERROR: ArgumentError: Package DataFrames not found in current path:\n- Run `import Pkg; Pkg.add(\"DataFrames\")` to install the DataFrames package.\n\nStacktrace:\n [1] require(::Module, ::Symbol) at ./loading.jl:893\n\njulia> # Specify a non-temp directory as the second argument if you want to reuse this environment across sessions.\n       Pkg.activate(jlso)\n Activating environment at `/var/folders/vz/zx_0gsp9291dhv049t_nx37r0000gn/T/Project.toml`\n\njulia> # Load our object and perhaps inspect some properties about it\n       # Could also choose export it to a more transparent format\n       using DataFrames\n\njulia> describe(jlso[:DataFrame])\n4Ã—8 DataFrame\nâ”‚ Row â”‚ variable â”‚ mean     â”‚ min      â”‚ median   â”‚ max      â”‚ nunique â”‚ nmissing â”‚ eltype   â”‚\nâ”‚     â”‚ Symbol   â”‚ Unionâ€¦   â”‚ Any      â”‚ Unionâ€¦   â”‚ Any      â”‚ Unionâ€¦  â”‚ Unionâ€¦   â”‚ DataType â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 1   â”‚ a        â”‚ 3.0      â”‚ 1        â”‚ 3.0      â”‚ 5        â”‚         â”‚          â”‚ Int64    â”‚\nâ”‚ 2   â”‚ b        â”‚ 0.772432 â”‚ 0.512452 â”‚ 0.863122 â”‚ 0.907903 â”‚         â”‚          â”‚ Float64  â”‚\nâ”‚ 3   â”‚ c        â”‚          â”‚ a        â”‚          â”‚ e        â”‚ 5       â”‚ 0        â”‚ Any      â”‚\nâ”‚ 4   â”‚ d        â”‚ 0.6      â”‚ 0        â”‚ 1.0      â”‚ 1        â”‚         â”‚          â”‚ Bool     â”‚","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"In the future, we may add some tooling to make it easier to view and compare these dictionaries, but it's currently unclear if that should live here or in Pkg.jl.","category":"page"}]
}
